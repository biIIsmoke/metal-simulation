// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> vertices;
StructuredBuffer<float3> defaultVertices; //to check maximum deform and also use it for elasticity, only gets set once, this will change if we go beyond maxElasticity and cause a plastic deformation

float3 grabPosition;
float3 currentPosition;
float grabSize;
float maxElasticity;
float maxDeform;

float distance(float3 point1, float3 point2)
{
    float x = point1.x - point2.x;
    float y = point1.y - point2.y;
    float z = point1.z - point2.z;

    return sqrt(x*x + y*y + z*z);
}

float3 direction(float3 point1, float3 point2)
{
    return normalize(point1 - point2); // Corrected to return a unit vector
}

[numthreads(512, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 vertex = vertices[id.x];
    float3 defaultVertex = defaultVertices[id.x]; // Correct assignment
    
    float distanceFromGrab = distance(vertex, grabPosition) - grabSize;
    float distanceFromCurrent = distance(vertex, currentPosition) - grabSize;
    float distanceFromDefault = distance(defaultVertex, vertex);
    
    if(distanceFromGrab > 0) // if distance from grab > 0, do calculative displacement
    {
        if(distanceFromDefault < maxElasticity)
        {
            // Elastic deformation
            vertex = defaultVertex + direction(currentPosition, vertex) * distanceFromCurrent * 0.1; // Scaled displacement for elasticity
        }
        else if(distanceFromDefault < maxDeform)
        {
            // Plastic deformation
            vertex = vertex + direction(currentPosition, vertex) * (distanceFromCurrent * 0.05); // Scaled displacement for plasticity
        }
        else
        {
            // Rupture
            // No additional displacement or maybe some rupture logic
        }
    }
    else // just add grab to current displacement
    {
        vertex = vertex + direction(currentPosition, grabPosition) * distanceFromCurrent * 0.5; // Apply displacement inside the grab size
    }

    vertices[id.x] = vertex;
}
