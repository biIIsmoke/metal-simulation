// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWStructuredBuffer<float3> vertices;
StructuredBuffer<float3> defaultVertices; //to check maximum deform and also use it for elasticity, only gets set once
float3 impactPoint;
float deformRadius;
float maxDeform;
float damageFalloff;
float damageMultiplier;
float minDamage;

float distance(float3 point1, float3 point2)
{
    float x = point1.x - point2.x;
    float y = point1.y - point2.y;
    float z = point1.z - point2.z;

    return sqrt(x*x+y*y+z*z);
}

[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 vertex = vertices[id.x];
    float3 defaultVertex = vertices[id.x];

    float distanceFromCollision = distance(vertex, impactPoint);
    float distanceFromOriginal = distance(defaultVertex, vertex);

    if (distanceFromCollision < deformRadius && distanceFromOriginal < maxDeform)
    {
        float falloff = 1 - (distanceFromCollision / deformRadius) * damageFalloff;

        float xDeform = impactPoint.x * falloff;
        float yDeform = impactPoint.y * falloff;
        float zDeform = impactPoint.z * falloff;

        xDeform = clamp(xDeform, 0, maxDeform);
        yDeform = clamp(yDeform, 0, maxDeform);
        zDeform = clamp(zDeform, 0, maxDeform);

        float3 deform = float3(xDeform, yDeform, zDeform);
        vertex -= deform * damageMultiplier;
    }
    else
    {
        //vertex += float3(1.0,0.0,0.0);
    }
    

    vertices[id.x] = vertex;
}
